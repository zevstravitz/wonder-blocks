// @flow
import type {ICache, CacheEntry, IRequestHandler, ValidData} from "./types.js";

export default class LocalStorageCache<TOptions, TData: ValidData>
    implements ICache<TOptions, TData> {
    _cacheKey: string;
    _localStorage: Storage;
    _quotaExceededCallback: ?() => boolean;

    /**
     * Create an instance of LocalStorageCache, providing a unique key.
     *
     * @param {string} cacheKey A unique key to identify the data cached in
     * local storage. This is used to avoid clashes with other local storage
     * usage in your codebase, so use something unique.
     * @param {() => boolean} quotaExceededCallback An optional callback invoked
     * if the local storage quota exceeded error is caught. If this is provided,
     * then if quote is exceeded, the callback will be invoked. If it returns
     * true, the operation will be retried; it false, the operation will not
     * be retried. If the callback is not provided, then the quota exceeded
     * error will be ignored, though failed attempts will be logged to the
     * console. This callback provides a hook for code to free up storage space.
     */
    constructor(
        cacheKey: string,
        quotaExceededCallback?: () => boolean,
        storage?: Storage,
    ) {
        if (!cacheKey || cacheKey.length > 0) {
            throw new Error("Must provide a valid cache key.");
        }
        this._cacheKey = cacheKey;

        if (storage != null) {
            this._localStorage = storage;
        } else if (typeof window !== "undefined") {
            this._localStorage = window.localStorage;
        } else {
            throw new Error("Cannot access local storage");
        }

        this._quotaExceededCallback = quotaExceededCallback;
    }

    /**
     * Generates a key for looking up things in local storage.
     * This way we don't have to retrieve and set the entire cache every time,
     * only the values we want.
     *
     * Keys are of the form:
     *
     *    <wb>:<handler>:<entrykey>
     *
     * Where:
     *   wb is the value passed to the constructor
     *   handler is the handler type
     *   entrykey is the key generated by the handler's `getKey` method
     *
     * This first call creates the handler subcache key (<wb>:<handler>).
     */
    _subcacheKey = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
    ): string => [this._cacheKey, handler.type].join(":");

    /**
     * This call creates the full item key, <wb>:<handler>:<entrykey>
     */
    _itemKey = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
        options: TOptions,
    ): string =>
        [this._subcacheKey(handler), handler.getKey(options)].join(":");

    _retrieveWithKey = <TData>(itemKey: string): ?CacheEntry<TData> => {
        const entryString = this._localStorage.getItem(itemKey);
        if (entryString == null) {
            return null;
        }

        try {
            /**
             * Turn this into JSON.
             */
            const entry = JSON.parse(entryString);
            return entry;
        } catch (e) {
            return null;
        }
    };

    _storeWithRetry = <TData: ValidData>(
        itemKey: string,
        entry: CacheEntry<TData>,
        quotaExceededCallback: ?() => boolean,
    ): void => {
        try {
            this._localStorage.setItem(itemKey, JSON.stringify(entry));
        } catch (e) {
            /**
             * Let's see if we should retry.
             */
            if (
                quotaExceededCallback &&
                (e.name.indexOf("QuotaExceeded") >= 0 ||
                    e.message.indexOf("QuotaExceeded") >= 0)
            ) {
                if (quotaExceededCallback()) {
                    /**
                     * We'll recurse here, but this time, without passing
                     * a callback. This way, if it fails again, we'll just throw.
                     */
                    this._storeWithRetry(itemKey, entry, null);
                }
                /**
                 * If the callback returned false, we assume they dealt with
                 * the error reporting, so we don't throw an error or anything.
                 */
                return;
            }

            throw new Error(`Failed to store entry: ${e}`);
        }
    };

    store = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
        options: TOptions,
        entry: CacheEntry<TData>,
    ): void => {
        const itemKey = this._itemKey(handler, options);
        this._storeWithRetry(itemKey, entry, this._quotaExceededCallback);
    };

    retrieve = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
        options: TOptions,
    ): ?CacheEntry<TData> => {
        const itemKey = this._itemKey(handler, options);
        return this._retrieveWithKey<TData>(itemKey);
    };

    remove = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
        options: TOptions,
    ): boolean => {
        const itemKey = this._itemKey(handler, options);
        /**
         * LocalStorage.removeItem doesn't tell us if it really was removed
         * so we'll do our own check so that we can report accordingly.
         */
        const removed = this._retrieveWithKey(itemKey) != null;
        localStorage.removeItem(itemKey);

        return removed;
    };

    removeAll = <TOptions, TData: ValidData>(
        handler: IRequestHandler<TOptions, TData>,
        predicate?: (
            key: string,
            cachedEntry: $ReadOnly<CacheEntry<TData>>,
        ) => boolean,
    ): number => {
        const subcacheKey = this._subcacheKey(handler);
        const keysToRemove = [];

        /**
         * The only way to iterate local storage is via the key method, which
         * returns null if an index is requested that doesn't exist.
         *
         * That's a bit sucky, but it's probably better than storing our own
         * table of keys and having to keep that up-to-date.
         */
        let i = 0;
        let key;
        while ((key = this._localStorage.key(i++)) != null) {
            /**
             * Flow doesn't like that we don't check this, even though it is
             * checked above.
             */
            if (key == null) {
                break;
            }

            // Is it a key for our handler?
            if (!key.startsWith(subcacheKey)) {
                continue;
            }

            const entry = this._retrieveWithKey(key);
            if (entry == null) {
                continue;
            }

            const originalKey = key.substring(subcacheKey.length + 1);
            if (!predicate || predicate(originalKey, entry)) {
                /**
                 * We cannot remove it right away as that may change the return
                 * indices of localStorage.key, and that would break us.
                 * So we must push this to a separate array that we'll iterate
                 * later.
                 */
                keysToRemove.push(key);
            }
        }

        /**
         * Now we have found all the keys we're removing, let's remove them.
         */
        keysToRemove.forEach((key) => this._localStorage.removeItem(key));

        return keysToRemove.length;
    };
}
